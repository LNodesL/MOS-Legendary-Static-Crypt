#!/usr/bin/env python3
"""
Packager tool that converts macOS executables to encrypted bytes and updates software.h
"""

import os
import sys
import argparse
from pathlib import Path

def encrypt_data(data, password):
    """Encrypt data using simple XOR encryption"""
    # For simplicity, we'll use a basic XOR with the password
    # In a real implementation, you'd want proper encryption
    
    encrypted_data = bytearray()
    password_bytes = password.encode()
    password_len = len(password_bytes)
    
    for i, byte in enumerate(data):
        encrypted_data.append(byte ^ password_bytes[i % password_len])
    
    return bytes(encrypted_data)

def read_executable(file_path):
    """Read executable file and return its bytes"""
    try:
        with open(file_path, 'rb') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file '{file_path}': {e}")
        sys.exit(1)

def generate_header_file(encrypted_data, output_path):
    """Generate software.h header file with encrypted bytes"""
    header_content = f"""#ifndef SOFTWARE_H
#define SOFTWARE_H

// Auto-generated by packager
// Contains encrypted executable as byte array

const unsigned char software_bytes[] = {{
"""
    
    # Format bytes as C array (16 bytes per line)
    for i in range(0, len(encrypted_data), 16):
        line_bytes = encrypted_data[i:i+16]
        hex_values = [f"0x{b:02x}" for b in line_bytes]
        header_content += "    " + ", ".join(hex_values)
        if i + 16 < len(encrypted_data):
            header_content += ","
        header_content += "\n"
    
    header_content += f"""}};

const unsigned int software_size = {len(encrypted_data)};

#endif // SOFTWARE_H
"""
    
    try:
        with open(output_path, 'w') as f:
            f.write(header_content)
        print(f"Generated header file: {output_path}")
        print(f"Embedded {len(encrypted_data)} encrypted bytes")
    except Exception as e:
        print(f"Error writing header file: {e}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="Package macOS executable into encrypted C header")
    parser.add_argument("executable", help="Path to the executable file to package")
    parser.add_argument("-o", "--output", default="../runtime/software.h", 
                       help="Output header file path (default: ../runtime/software.h)")
    parser.add_argument("-p", "--password", default="mos-legendary-crypt-2024", 
                       help="Encryption password (default: mos-legendary-crypt-2024)")
    
    args = parser.parse_args()
    
    # Check if executable exists
    if not os.path.exists(args.executable):
        print(f"Error: Executable '{args.executable}' not found")
        sys.exit(1)
    
    # Read executable bytes
    print(f"Reading executable: {args.executable}")
    bytes_data = read_executable(args.executable)
    
    # Encrypt the data
    print(f"Encrypting executable with password...")
    encrypted_data = encrypt_data(bytes_data, args.password)
    
    # Generate header file
    print(f"Generating header file: {args.output}")
    generate_header_file(encrypted_data, args.output)
    
    print("Encrypted packaging complete!")

if __name__ == "__main__":
    main()
